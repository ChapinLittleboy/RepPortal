@page "/monthly-sales-report"
@attribute [Authorize]
@using System.Dynamic
@using System.Globalization
@using Microsoft.CodeAnalysis.Operations
@using RepPortal.Services
@using RepPortal.Data
@using RepPortal.Models
@using Syncfusion.Blazor.Grids
@inject SalesService SalesService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject UserManager<ApplicationUser> UserManager
@inject IRepCodeContext RepCodeContext

<SfSpinner Size="100" Type="SpinnerType.Bootstrap5" Visible="@isLoading"></SfSpinner>
<h5>Monthly Sales Report</h5>

@if (isLoading)
{
    <p>Loading sales data, please wait...</p>
}
else
{
    if (isReady)
    {



        <SfGrid ID="Grid" @ref="Grid" DataSource="@eSalesData" AllowSorting="true"
        AllowFiltering="true" AllowPaging="true" AllowExcelExport="true" AllowResizing="true" AllowTextWrap="true"
        Toolbar="@(new List<string>() { "Export to Excel" })" AllowReordering="true">
            <GridEvents OnToolbarClick="ToolbarClickHandler" TValue="ExpandoObject"></GridEvents>
            <GridTextWrapSettings WrapMode="WrapMode.Header"></GridTextWrapSettings>
            <GridPageSettings PageSizes="@(new string[] {"10", "20", "50", "100",  "All" })"  PageSize="20" ></GridPageSettings>
            <GridFilterSettings Type="Syncfusion.Blazor.Grids.FilterType.Excel"></GridFilterSettings>
            <GridAggregates>
                <GridAggregate>
                    <GridAggregateColumns>
                        @foreach (var colName in DynamicColumns)
                        {
                            <GridAggregateColumn Field="@colName" Type="AggregateType.Sum" Format="C0">
                                <FooterTemplate>
                                    @{
                                        var aggregate = (context as AggregateTemplateContext);
                                    }
                                    <div>@aggregate.Sum</div>
                                </FooterTemplate>
                            </GridAggregateColumn>
                        }
                    </GridAggregateColumns>
                </GridAggregate>

            </GridAggregates>
            <GridColumns>
                <!-- Fixed Columns -->
                <GridColumn Field="Customer" HeaderText="Customer" Width="100"></GridColumn>
                <GridColumn Field="Customer Name" HeaderText="Name" Width="150"></GridColumn>
                <GridColumn Field="Bill To State" HeaderText="Bill State" Width="100"></GridColumn>
                <GridColumn Field="Ship To Num" HeaderText="Ship To" Width="100"></GridColumn>
                <GridColumn Field="Ship To City" HeaderText="Ship City" Width="120"></GridColumn>
                <GridColumn Field="Ship To State" HeaderText="Ship State" Width="120"></GridColumn>
                <GridColumn Field="slsman" HeaderText="Salesman" Width="120"></GridColumn>

                <GridColumn Field="RegionName" HeaderText="Region" Width="120"></GridColumn>

                <!-- Dynamic Columns -->
                @foreach (var column in DynamicColumns)
                {
                    <GridColumn Field="@column" HeaderText="@column" Format="C0"  Width="120"></GridColumn>
                }
            </GridColumns>
        </SfGrid>
    }
}


@code {
    private SfGrid<ExpandoObject> Grid;
    private List<Dictionary<string, object>> SalesData = new List<Dictionary<string, object>>();
    private List<string> DynamicColumns = new List<string>();
    private List<ExpandoObject> eSalesData = new List<ExpandoObject>();
    private bool isLoading = true;
    private bool isReady = false;


    private AuthenticationState authState;
    private ApplicationUser currentUser;



    protected override async Task OnInitializedAsync()
    {
        authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity.IsAuthenticated)
        {
            currentUser = await UserManager.GetUserAsync(user);
        }

        var rawData = await SalesService.GetSalesReportData();
        ProcessDynamicColumns(rawData);
        ConvertToDictionaries(rawData);

        eSalesData = SalesData.Select(d => d.ToExpando()).ToList();
        await base.OnInitializedAsync();
        // Hide the spinner
        isLoading = false;
        //spinner.HideAsync();
        isReady = true;
    }



    public async Task ToolbarClickHandler(Syncfusion.Blazor.Navigations.ClickEventArgs args)
    {
        if (args.Item.Id == "Grid_Export to Excel") //Id is combination of Grid's ID and itemname
        {
            var ExcelFileName = $"Chapin Monthly Sales Report({currentUser.RepCode}).xlsx";
            ExcelExportProperties exportProperties = new ExcelExportProperties
            {
                    FileName = ExcelFileName
            };
            await this.Grid.ExportToExcelAsync(exportProperties);
        }
    }
    private void ConvertToDictionaries(List<Dictionary<string, object>> records)
    {
        // No conversion needed since records is already List<Dictionary<string, object>>
        SalesData = records;
    }

    private void ProcessDynamicColumns(List<Dictionary<string, object>> records)
    {
        // Get all possible dynamic column names
        var allColumns = records
            .SelectMany(r => r.Keys)
            .Where(k => !IsFixedColumn(k))
            .Distinct()
            .OrderBy(GetColumnOrder)
            .ToList();

        DynamicColumns = allColumns;

        // Debugging: Log the dynamic columns
        Console.WriteLine("Dynamic Columns: " + string.Join(", ", DynamicColumns));
    }

    private bool IsFixedColumn(string columnName)
    {
        var fixedColumns = new HashSet<string> 
        { 
            "Customer", "Customer Name", "Ship To Num", "Ship To City", "Ship To State"
            , "slsman", "name",
            "Bill To State",  "Uf_SalesRegion" ,"RegionName"
        };
        return fixedColumns.Contains(columnName);
    }
    private int GetColumnOrder(string columnName)
    {
        // Handle fixed columns (if needed)
        var fixedColumnOrder = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
        {
            { "Customer", 0 },
            { "Customer Name", 1 },
            { "Ship To Num", 2 },
            { "Ship To City", 3 },
            { "Ship To State", 4 },
            { "Slsman", 5 },
            { "Name", 6 },
            { "Bill To State", 7 },
            { "Uf_SalesRegion", 8 },
            { "RegionName", 9 }
        };

        if (fixedColumnOrder.ContainsKey(columnName))
        {
            return fixedColumnOrder[columnName];
        }

        // Handle dynamic columns (chronological order)
        if (columnName.StartsWith("FY", StringComparison.OrdinalIgnoreCase))
        {
            // Extract the integer part after "FY"
            if (int.TryParse(columnName.Substring(2), out int year))
            {
                // Return a value based on the year
                // For example, FY2024 returns 10, FY2025 returns 11, etc.
                return year - 2014; // Adjust the offset as needed
            }
            else
            {
                // Handle the case where the column name doesn't contain a valid year
                return int.MaxValue; // Place invalid FY columns at the end
            }
        }
        // Parse month-year columns (e.g., SEP2024, OCT2024, etc.)
        if (columnName.Length >= 3)
        {
            var monthPart = columnName.Substring(0, 3);
            var yearPart = columnName.Length > 3 ? columnName.Substring(3) : "";

            int previouscolumns = 11;
            var monthOrder = monthPart.ToUpper() switch
            {
                "SEP" => previouscolumns + 1,
                "OCT" => previouscolumns + 2,
                "NOV" => previouscolumns + 3,
                "DEC" => previouscolumns + 4,
                "JAN" => previouscolumns + 5,
                "FEB" => previouscolumns + 6,
                "MAR" => previouscolumns + 7,
                "APR" => previouscolumns + 8,
                "MAY" => previouscolumns + 9,
                "JUN" => previouscolumns + 10,
                "JUL" => previouscolumns + 11,
                "AUG" => previouscolumns + 12,
                
                _ => -1 // Unknown month
            };

            if (monthOrder != -1)
            {
                return monthOrder;
            }
        }

        // Default for unmatched columns
        return int.MaxValue; // Place unmatched columns at the end
    }

    private int GetColumnOrderX(string columnName)
    {
        // Implement logic to order columns chronologically

        return columnName switch
        {
            "Customer" => 0,
            "CustomerName" => 1,
            "ShipToNum" => 2,
            "Slsman" => 3,
            "Name" => 4,
            "BillToState" => 5,
            "Uf_SalesRegion" => 6,
            "RegionName" => 7,
            _ when columnName.StartsWith("FY") => 8,
        _ when columnName.StartsWith("SEP", StringComparison.OrdinalIgnoreCase) => 9,
            _ when columnName.StartsWith("OCT", StringComparison.OrdinalIgnoreCase) => 10,
            _ when columnName.StartsWith("NOV", StringComparison.OrdinalIgnoreCase) => 11,
            _ when columnName.StartsWith("DEC", StringComparison.OrdinalIgnoreCase) => 12,
            _ when columnName.StartsWith("JAN", StringComparison.OrdinalIgnoreCase) => 13,
            _ when columnName.StartsWith("FEB", StringComparison.OrdinalIgnoreCase) => 14,
            _ when columnName.StartsWith("MAR", StringComparison.OrdinalIgnoreCase) => 15,
            _ when columnName.StartsWith("APR", StringComparison.OrdinalIgnoreCase) => 16,
            _ when columnName.StartsWith("MAY", StringComparison.OrdinalIgnoreCase) => 17,
            _ when columnName.StartsWith("JUN", StringComparison.OrdinalIgnoreCase) => 18,
            _ when columnName.StartsWith("JUL", StringComparison.OrdinalIgnoreCase) => 19,
            _ when columnName.StartsWith("AUG", StringComparison.OrdinalIgnoreCase) => 20,
            _ => -1 // or some default value if none of the above match
    };

    }

    private void ConvertToExpandoObjects(List<SalesRecord> records)
    {
        foreach (var record in records)
        {
            dynamic expando = new ExpandoObject();
            var dict = expando as IDictionary<string, object>;

            foreach (var kvp in record)
            {
                dict[kvp.Key] = kvp.Value;
            }

            SalesData.Add(expando);
        }
    }

 
}