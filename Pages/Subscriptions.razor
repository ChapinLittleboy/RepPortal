@page "/subscriptions"
@attribute [Authorize]
@inject NavigationManager Nav
@inject IJSRuntime JS
@using Hangfire
@using Hangfire.Storage
@using RepPortal.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Syncfusion.Blazor
@using Syncfusion.Blazor.DropDowns
@using ChangeEventArgs = Microsoft.AspNetCore.Components.ChangeEventArgs
@using FilterType = Syncfusion.Blazor.DropDowns.FilterType
@inject AuthenticationStateProvider AuthStateProvider

<PageTitle>Subscriptions</PageTitle>

<h3>Your Subscriptions</h3>

@if (_subs is null)
{
    <p><em>Loading subscriptions...</em></p>
}
else if (_subs.Count == 0)
{
    <p>No active subscriptions.</p>
}
else
{
    <table class="table table-striped">
        <thead>
            <tr>
                <th>Report</th>
               
                <th>Customer</th>
                <th>Date Range</th>
                <th>Schedule</th>
                <th>Time Zone</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (var sub in _subs)
            {
                <tr>
                    <td>@sub.ReportType</td>
                    
                    <td>@(sub.CustomerId ?? "ALL")</td>
                    <td>@DescribeDateRange(sub.DateRangeCode)</td>
                    <td>@DescribeCron(sub.Cron, sub.TimeZone)</td>
                    <td>@sub.TimeZone</td>
                    <td>
                        <button class="btn btn-danger btn-sm"
                                @onclick="() => Remove(sub)">
                            Remove
                        </button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
}

<hr />

<h4>New Subscription</h4>

<EditForm Model="_newSub" OnValidSubmit="Add">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="mb-2">
        <label>Report</label>

        <SfDropDownList TValue="ReportType"
                        TItem="ReportTypeOption"
                        DataSource="@ReportTypeOptions"
                        Placeholder="Select report"
                        Width="25%"
                        @bind-Value="_newSub.ReportType"
                        @bind-Value:after="ReportType_Change">
            <DropDownListFieldSettings Text="Text" Value="Value" />
        </SfDropDownList>
    </div>
    <div class="mb-2">
        <label>Email</label>
        <InputText @bind-Value="_newSub.Email" class="form-control" readonly />
    </div>

    <div class="row">
    <div class="col-md-6">
        <div class="form-group mb-3">
            <label>Customer Name (Optional):</label>
            <SfComboBox TValue="string"
                        TItem="Customer"
                        @bind-Value="_newSub.CustomerId"
                        DebounceDelay="@ComboDebounceMs"
                        AllowFiltering="true"
                        FilterType="FilterType.Contains"
                        DataSource="@CustomerList"
                        Placeholder="Type to search customers…"
                        Enabled="@AllowCustSelection"
                        @ref="WantedCust">
                <ComboBoxFieldSettings Text="CustNameWithNum" Value="Cust_Num" />
            </SfComboBox>

            <small class="form-text text-muted">
                Leave blank to subscribe for ALL customers.
            </small>
        </div>
    </div>
    </div>

   
    <div class="mb-2">
        <label>Date Range (Optional)</label>

        <SfDropDownList TValue="DateRangeCodeType"
                        TItem="DateRangeTypeOption"
                        DataSource="@DateRangeOptions"
                        Placeholder="Select a date range"
                        Width="25%"
                        Enabled="@AllowDateRangeSelection"
                        @bind-Value="_newSub.DateRangeCode"
                        @bind-Value:after="DateRange_Change">
            <DropDownListFieldSettings Text="Text" Value="Value" />
        </SfDropDownList>

        @if (!AllowDateRangeSelection)
        {
            <small class="text-muted">Date range applies only to InvoicedAccounts or Shipments.</small>
        }
    </div>

    
    
    
    
    


    <div class="mb-2">
        
        <CronPicker @bind-Value="_newSub.Cron" />
        
    </div>

    <div class="mb-2">
        <label>Time Zone</label>
        <InputText @bind-Value="_newSub.TimeZone" class="form-control" />
    </div>

    <button type="submit" class="btn btn-primary">Add Subscription</button>
</EditForm>

@code {
    [Inject] private CustomerService CustomerService { get; set; } = default!;
    private List<SubscriptionVm>? _subs;
    private string? _currentUserEmail;
    private int ComboDebounceMs { get; set; } = 300;
    // Data sources for the two inputs
    private List<Customer> CustomerList { get; set; } = new();
    private bool AllowCustSelection = false;
    private bool AllowDateRangeSelection = false;
    public DateRangeCodeType DateRangeCode { get; set; } = DateRangeCodeType.CurrentMonth;

    // Reference to the combo (optional, if you want to interact with it)
    private SfComboBox<string, Customer>? WantedCust;
    private NewSubVm _newSub = new();


    

    private List<ReportTypeOption> ReportTypeOptions { get; set; } = new();
    private List<DateRangeTypeOption> DateRangeOptions { get; set; } =
        DateRangeOrder
            .Select(dt => new DateRangeTypeOption
            {
                Text  = GetDateRangeDisplay(dt),
                Value = dt
            })
            .ToList();

    protected override async Task OnInitializedAsync()
    {
        var auth = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = auth.User;



        _currentUserEmail = user.FindFirst("email")?.Value
                            ?? user.Identity?.Name
                            ?? throw new InvalidOperationException("Could not determine user email.");
        CustomerList = await CustomerService.GetCustomersDetailsByRepCodeAsync();

        AllowCustSelection = _newSub.ReportType is ReportType.InvoicedAccounts or ReportType.Shipments;
        AllowDateRangeSelection = AllowCustSelection;

        ReportTypeOptions = Enum.GetValues<ReportType>()
            .Where(rt =>
                rt != ReportType.ExpiringPCFNotications
                || _currentUserEmail.Equals(
                    "wlittleboy@chapinmfg.com",
                    StringComparison.OrdinalIgnoreCase))
            .Select(rt => new ReportTypeOption
            {
                Text = GetReportDisplay(rt),
                Value = rt
            })
            .ToList();

        Load();
    }

    private void Load()
    {
        using var conn = JobStorage.Current.GetConnection();
        var jobs = conn.GetRecurringJobs()
            .Where(j => j.Id.StartsWith("subs:") && j.Id.Contains(_currentUserEmail!, StringComparison.OrdinalIgnoreCase))
            .ToList();

        _subs = jobs.Select(Parse).ToList();
    }
    private static string GetReportDisplay(ReportType rt)
    {
        // Optionally map to friendly names; default is enum name
        return rt.ToString();
    }
    private static string GetDateRangeDisplay(DateRangeCodeType dt) => dt switch
    {
        DateRangeCodeType.PriorMonth           => "Prior Month",
        DateRangeCodeType.CurrentMonth         => "Current Month (MTD)",
        DateRangeCodeType.PriorAndCurrentMonth => "Prior + Current Month",
        DateRangeCodeType.AllDates             => "All Dates",
        _                                      => dt.ToString()
    };
    private SubscriptionVm Parse(RecurringJobDto job)
    {
        // ID format: subs:ReportType:Email:CustomerId:DateRange
        var parts = job.Id.Split(':');
        return new SubscriptionVm
        {
            Id = job.Id,
            ReportType = Enum.TryParse<ReportType>(parts[1], out var rt) ? rt : ReportType.MonthlySales,
            Email = parts[2],
            CustomerId = parts.Length > 3 && parts[3] != "ALL" ? parts[3] : null,
            DateRangeCode = parts.Length > 4 && parts[4] != "DEFAULT" ? parts[4] : null,
            Cron = job.Cron,
            TimeZone = job.TimeZoneId
        };
    }

    private void Add()
    {
        if (_currentUserEmail is null) return;

        _newSub.Email = _currentUserEmail;

        ReportSubscriptions.Upsert(
            _newSub.ReportType,
            _newSub.Email,
            _newSub.CustomerId,
            _newSub.DateRangeCode.ToString(),
            _newSub.Cron,
            _newSub.TimeZone);

        Load();
        _newSub = new() { Email = _currentUserEmail };
    }

    private void Remove(SubscriptionVm sub)
    {
        RecurringJob.RemoveIfExists(sub.Id);
        Load();
    }

    private void ReportType_Change()
    {
        // Customer selection allowed only for InvoicedAccounts or Shipments?
        AllowCustSelection = _newSub.ReportType is ReportType.InvoicedAccounts or ReportType.Shipments;

        // Date range allowed only for those same reports
        AllowDateRangeSelection = AllowCustSelection;

        if (!AllowCustSelection)
        {
            _newSub.CustomerId = null; // clears SfComboBox selection via binding
        }

        if (!AllowDateRangeSelection)
        {
            _newSub.DateRangeCode = DateRangeCodeType.AllDates; // reset to default when not applicable
        }

        StateHasChanged();
    }
        
    private void ClearWantedCustSelection()
    {
        // Set the bound value to null or empty
        _newSub.CustomerId = null;

        // Refresh the ComboBox UI
         WantedCust!.ClearAsync();
         InvokeAsync(StateHasChanged);
    }

    private sealed class ReportTypeOption
    {
        public string Text { get; set; } = "";
        public ReportType Value { get; set; }
    }
    private sealed class DateRangeTypeOption
    {
        public string Text { get; set; } = "";
        public DateRangeCodeType Value { get; set; }
    }


    private sealed class SubscriptionVm
    {
        public string Id { get; set; } = default!;
        public ReportType ReportType { get; set; }
        public string Email { get; set; } = default!;
        public string? CustomerId { get; set; }
        public string? DateRangeCode { get; set; }
        public string Cron { get; set; } = default!;
        public string TimeZone { get; set; } = default!;
    }

    private sealed class NewSubVm
    {
        public ReportType ReportType { get; set; } = ReportType.MonthlyInvoicedSales;
        public string Email { get; set; } = "";
        public string? CustomerId { get; set; }
        public DateRangeCodeType DateRangeCode { get; set; } = DateRangeCodeType.AllDates;
        public string Cron { get; set; } = "0 6 * * 1-5";
        public string TimeZone { get; set; } = "America/New_York";
    }
    private static string DescribeCron(string cron, string timeZoneId)
    {
        if (string.IsNullOrWhiteSpace(cron)) return "";

        var parts = cron.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 5) return cron;

        // minute hour day-of-month month day-of-week
        if (!int.TryParse(parts[0], out var minute)) return cron;
        if (!int.TryParse(parts[1], out var hour)) return cron;
        var dom = parts[2];
        var dow = parts[4];

        var timeText = FormatTime(hour, minute, timeZoneId);

        // Daily: m h * * *
        if (dom == "*" && dow == "*")
            return $"Daily at {timeText}";

        // Weekdays: m h * * 1-5
        if (dom == "*" && string.Equals(dow, "1-5", StringComparison.Ordinal))
            return $"Weekdays at {timeText}";

        // Weekly: m h * * d (0=Sunday ... 6=Saturday)
        if (dom == "*" && int.TryParse(dow, out var dowInt) && dowInt is >= 0 and <= 6)
            return $"Every {Enum.GetName(typeof(DayOfWeek), dowInt)} at {timeText}";

        // Monthly: m h D * *
        if (dow == "*" && int.TryParse(dom, out var day) && day is >= 1 and <= 31)
            return $"Monthly on the {Ordinal(day)} at {timeText}";

        // Fallback
        return cron;
    }

    private static string FormatTime(int hour, int minute, string timeZoneId)
    {
        // Cron is evaluated in the job's time zone; we just pretty-print the local hh:mm AM/PM.
        // If you want to append TZ abbrev, you can — but abbreviations are messy across platforms.
        try
        {
            // This try/catch is just to be resilient if TZ is invalid on the host.
            var _ = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
            var dt = new DateTime(2000, 1, 1, hour, minute, 0);
            return dt.ToString("h:mm tt");
        }
        catch
        {
            return $"{hour:00}:{minute:00}";
        }
    }

    private static string Ordinal(int n)
    {
        // 1 -> 1st, 2 -> 2nd, 3 -> 3rd, 4 -> 4th, …
        if (n % 100 is 11 or 12 or 13) return $"{n}th";
        return (n % 10) switch
        {
            1 => $"{n}st",
            2 => $"{n}nd",
            3 => $"{n}rd",
            _ => $"{n}th"
        };
    }


    public sealed class CustomerTypeVm
    {
        public string CustomerType { get; set; } = "";
        public string DisplayText { get; set; } = "";
    }
    private static string DescribeDateRange(string? code)
    {
        if (string.IsNullOrWhiteSpace(code)) return "DEFAULT";
        return Enum.TryParse<DateRangeCodeType>(code, out var parsed)
            ? GetDateRangeDisplay(parsed)
            : code; // fallback to raw
    }
    private void DateRange_Change() { /* reserved for future validation */ }
    private static readonly DateRangeCodeType[] DateRangeOrder =
    {
        DateRangeCodeType.PriorMonth,
        DateRangeCodeType.CurrentMonth,
        DateRangeCodeType.PriorAndCurrentMonth,
        DateRangeCodeType.AllDates
    };
}
