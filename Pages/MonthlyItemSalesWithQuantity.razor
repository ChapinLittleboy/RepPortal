@page "/monthly-item-sales-with-qty"
@attribute [Authorize]
@using System.Dynamic
@using System.Globalization
@using Microsoft.CodeAnalysis.CSharp.Syntax
@using RepPortal.Services
@using RepPortal.Data
@using RepPortal.Models
@using Syncfusion.Blazor.Grids
@using Syncfusion.Blazor.Buttons
@inject SalesService SalesService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject UserManager<ApplicationUser> UserManager
@inject IRepCodeContext RepCodeContext
@inject RepPortal.Services.IActivityLogService ActivityLogService

<SfSpinner Size="100" Type="SpinnerType.Bootstrap5" Visible="@isLoading"></SfSpinner>

@if (isLoading)
{
    <p>Loading sales data, please wait...</p>
}
else
{
    <!-- Toggle button for switching between Revenue and Quantity columns -->
    <div style="margin-bottom: 10px;">
        <SfButton OnClick="ToggleDataType">Toggle Revenue or Quantity</SfButton>
        <span style="margin-left:20px;">@(showRevenue ? "Showing Revenue Data" : "Showing Quantity Data")</span>
    </div>

    <SfGrid ID="Grid" @ref="Grid" DataSource="@eSalesData" AllowSorting="true" AllowFiltering="true" AllowPaging="true" ShowColumnChooser="true" AllowReordering="true"
    AllowGrouping="true" AllowExcelExport="true"
    Toolbar="@(new List<string>() { "Export to Excel" , "ColumnChooser"})" AllowResizing="true" AllowTextWrap="true">
        <GridEvents OnToolbarClick="ToolbarClickHandler" TValue="ExpandoObject"></GridEvents>
        <GridTextWrapSettings WrapMode="WrapMode.Header"></GridTextWrapSettings>
        <GridPageSettings PageSizes="@(new string[] { "20", "50", "100",  "All" })" PageSize="20"></GridPageSettings>
        <GridFilterSettings Type="Syncfusion.Blazor.Grids.FilterType.Excel"></GridFilterSettings>


        <GridColumns>
            <!-- Fixed Columns -->
            <GridColumn Field="Customer" HeaderText="Customer" Width="100"></GridColumn>
            <GridColumn Field="Customer Name" HeaderText="Name" Width="150"></GridColumn>
            <GridColumn Field="Ship To Num" HeaderText="Ship To" Width="100"></GridColumn>
            <GridColumn Field="Ship To City" HeaderText="Ship City" Width="120"></GridColumn>
            <GridColumn Field="Ship To State" HeaderText="Ship State" Width="120"></GridColumn>
            <GridColumn Field="slsman" HeaderText="Salesman" Width="120"></GridColumn>
            <GridColumn Field="Bill To State" HeaderText="Bill State" Width="100"></GridColumn>
            <GridColumn Field="RegionName" HeaderText="Region" Width="120"></GridColumn>
            <GridColumn Field="Item" HeaderText="Item" Width="120"></GridColumn>
            <GridColumn Field="ItemDescription" HeaderText="Description" Width="120"></GridColumn>

            <!-- Dynamic Columns -->
            @foreach (var column in DynamicColumnsToShow)
            {
                // Determine if it's Revenue or Quantity based on name
                bool isRevenueColumn = column.EndsWith("_Rev", StringComparison.OrdinalIgnoreCase);
                string format = isRevenueColumn ? "C0" : "N0"; // C0 for Rev, N0 for Qty
                var header = column.Replace("_", " "); // Header: "FY2024 Rev", "FY2024 Qty"

                // Optional: You could use the showRevenue flag to *skip* columns you don't want
                // bool shouldShowColumn = (isRevenueColumn && showRevenue) || (!isRevenueColumn && !showRevenue);
                // if (shouldShowColumn) { ... }
                // --- OR --- just show all columns from the list and format appropriately:

                <GridColumn Field="@column" HeaderText="@header" Format="@format" Width="140" TextAlign="TextAlign.Right"></GridColumn>
            }

        </GridColumns>
        <GridAggregates>
            <GridAggregate>
                <GridAggregateColumns>
                    @foreach (var column in DynamicColumnsToShow) // e.g., "FY2024_Rev", "FY2024_Qty"
                    {
                        // Determine the REQUIRED format for the TEMPLATE based on column name
                        bool isRevenueColumn = column.EndsWith("_Rev", StringComparison.OrdinalIgnoreCase);
                        string templateFormat = isRevenueColumn ? "C0" : "N0";

                        // Define the aggregate column WITHOUT the Format attribute.
                        // This should instruct the grid to return the raw SUM value (hopefully numeric).
                        <GridAggregateColumn Field="@column" Type="AggregateType.Sum">

                            @* Group Footer Template: Apply formatting here   LOTS OF WORK NEEDED to implement *@


                            @* Footer Template: Apply formatting here *@
                            <FooterTemplate>
	                            @{
		                            string formattedSum = "N/A";
		                            // Lookup still uses the 'column' variable, which is correct.
		                            // CalculatedSums should contain entries for ALL keys now.
		                            if (aggregatesCalculated && CalculatedSums.TryGetValue(column, out decimal manualSum))
		                            {
			                            // Determine format based on column name
			                            bool isRevenueColumn = column.EndsWith("_Rev", StringComparison.OrdinalIgnoreCase);
			                            string templateFormat = isRevenueColumn ? "C0" : "N0";
			                            try { formattedSum = manualSum.ToString(templateFormat); } catch { formattedSum = "Format Err"; }
		                            }
		                            // ... other conditions ...
	                            }
	                            <div><p>Total: @formattedSum</p></div>
                            </FooterTemplate>

                        </GridAggregateColumn>
                    }
                </GridAggregateColumns>
            </GridAggregate>
        </GridAggregates>

    </SfGrid>
}


@code {
    private SfGrid<ExpandoObject> Grid;
    private List<Dictionary<string, object>> SalesData = new List<Dictionary<string, object>>();
    private List<string> DynamicColumns = new List<string>();
    private List<ExpandoObject> eSalesData = new List<ExpandoObject>();
    private bool isLoading = true;

    private AuthenticationState authState;
    private ApplicationUser currentUser;
    private bool showRevenue = true; // Flag to toggle between Revenue and Quantity

    // Dictionary to store manually calculated aggregates
    private Dictionary<string, decimal> CalculatedSums = new Dictionary<string, decimal>();
    public List<string> DynamicColumnsToShow { get; private set; } = new List<string>();


    // Flag to indicate if calculation is done
    private bool aggregatesCalculated = false;

    // Define ALL keys that require aggregation
    private List<string> KeysToAggregatexx = new List<string> {
	    // Add ALL _Rev and _Qty keys that might appear in your grid
	    "FY2024_Rev", "FY2024_Qty",
	    "FY2025_Rev", "FY2025_Qty",
	    "Sep2024_Rev", "Sep2024_Qty",
	    "Oct2024_Rev", "Oct2024_Qty",
	    "Nov2024_Rev", "Nov2024_Qty",
	    "Dec2024_Rev", "Dec2024_Qty",
	    "Jan2025_Rev", "Jan2025_Qty",
	    "Feb2025_Rev", "Feb2025_Qty",
	    "Mar2025_Rev", "Mar2025_Qty",
	    "Apr2025_Rev", "Apr2025_Qty",
	    "May2025_Rev", "May2025_Qty"
	    // Add any other monthly or yearly keys...
    };

	private List<string> KeysToAggregate = new List<string>();

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;
        aggregatesCalculated = false;

        authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity.IsAuthenticated)
        {
            currentUser = await UserManager.GetUserAsync(user);
        }

        // Log report usage (no parameters for listing page)
        await ActivityLogService.LogReportUsageActivityAsync("Monthly Item Historic Sales Report", "");

        var rawData = await SalesService.GetItemSalesReportDataWithQty();
        //ProcessDynamicColumns(rawData);
        ProcessDynamicColumnsAndPopulateKeysToAggregate(rawData);
        SalesData = rawData;


        ConvertToDictionaries(rawData);

        SalesData = SalesData
	        .OrderBy(d => d.ContainsKey("Customer Name") ? d["Customer Name"]?.ToString() : null)
	        .ThenBy(d => d.ContainsKey("Item") ? d["Item"]?.ToString() : null)
	        .ThenBy(d => d.ContainsKey("Ship To Num") ? d["Ship To Num"]?.ToString() : null)
	        .ToList();

        eSalesData = SalesData.Select(d => d.ToExpando()).ToList();
        
        // --- Add this Debug Logging ---



        // --- Calculate aggregates for ALL keys ---
        // 4. Calculate and set the initial list of columns to show
        UpdateDynamicColumnsToShow(); 
        CalculateManualAggregates();
    
 

        await base.OnInitializedAsync();
        // Hide the spinner
        isLoading = false;
        //spinner.HideAsync();
    }

    private void CalculateManualAggregates()
    {
	    Console.WriteLine("Calculating Manual Aggregates for ALL keys..."); // Debug log
	    CalculatedSums.Clear();
	    if (eSalesData == null || !eSalesData.Any())
	    {
		    aggregatesCalculated = true;
		    return;
	    }

	    // Loop through the complete list of keys needing sums
	    foreach (var columnKey in KeysToAggregate)
	    {
		    // Check if the key exists in the first row just to be safe
		    // (Assumes all rows have the same keys as the first)
		    var firstRow = eSalesData.First() as IDictionary<string, object>;
		    if (!firstRow.ContainsKey(columnKey)) {
			    Console.WriteLine($"Warning: Key '{columnKey}' not found in data, skipping aggregation.");
			    CalculatedSums[columnKey] = 0; // Store 0 if key is expected but missing
			    continue;
		    }

		    decimal currentSum = 0;
		    foreach (var rowObject in eSalesData)
		    {
			    var rowDict = (IDictionary<string, object>)rowObject;
			    if (rowDict.TryGetValue(columnKey, out var value) && value != null)
			    {
				    if (decimal.TryParse(value.ToString(), System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out decimal decimalValue))
				    {
					    currentSum += decimalValue;
				    }
			    }
		    }
		    CalculatedSums[columnKey] = currentSum; // Store sum for this key
		    Console.WriteLine($"DEBUG MANUAL SUM: Key='{columnKey}', Sum={currentSum}"); // Optional debug log
	    }
	    aggregatesCalculated = true;
	    Console.WriteLine("Finished Calculating Manual Aggregates.");
    }

    public async Task ToolbarClickHandler(Syncfusion.Blazor.Navigations.ClickEventArgs args)
    {
        if (args.Item.Id == "Grid_Export to Excel") //Id is combination of Grid's ID and itemname
        {
            var ExcelFileName = $"Chapin Monthly Sales Report({RepCodeContext.CurrentRepCode}).xlsx";
            // Log report usage (no parameters for listing page)
            await ActivityLogService.LogReportUsageActivityAsync("Monthly Item Sales Historic Report Export", ExcelFileName);
            ExcelExportProperties exportProperties = new ExcelExportProperties
                {
                    FileName = ExcelFileName
                };
            await this.Grid.ExportToExcelAsync(exportProperties);
        }
    }
    private void ConvertToDictionaries(List<Dictionary<string, object>> records)
    {
        // No conversion needed since records is already List<Dictionary<string, object>>
        SalesData = records;
    }

    private void ProcessDynamicColumns(List<Dictionary<string, object>> records)
    {
//
       // Console.WriteLine("Records: " + string.Join(Environment.NewLine, records.Select(record =>
       //     string.Join(", ", record.Select(kvp => $"{kvp.Key}: {kvp.Value}")))));

        // Get all possible dynamic column names
        var allColumns = records
            .SelectMany(r => r.Keys)
            .Where(k => !IsFixedColumn(k))
            .Distinct()
            .OrderBy(GetColumnOrder)
            .ToList();

        DynamicColumns = allColumns;

        // Debugging: Log the dynamic columns
        Console.WriteLine("Dynamic Columns: " + string.Join(", ", DynamicColumns));
    }

    private bool IsFixedColumn(string columnName)
    {
        var fixedColumns = new HashSet<string>
        {
            "Customer", "Customer Name", "Ship To Num", "Ship To City", "Ship To State"
            , "slsman", "name",
            "Bill To State",  "Uf_SalesRegion" ,"RegionName","Item","ItemDescription"
        };
        return fixedColumns.Contains(columnName);
    }
    private int GetColumnOrder(string columnName)
    {
        // Handle fixed columns (if needed)
        var fixedColumnOrder = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
        {
            { "Customer", 0 },
            { "Customer Name", 1 },
            { "Ship To Num", 2 },
            { "Ship To City", 3 },
            { "Ship To State", 4 },
            { "Slsman", 5 },
            { "Name", 6 },
            { "SalesPersonName", 6 },
            { "Bill To State", 7 },
            { "Uf_SalesRegion", 8 },
            { "RegionName", 9 },
            { "Item", 10 },
        { "ItemDescription", 11 }
        };

        if (fixedColumnOrder.ContainsKey(columnName))
        {
            return fixedColumnOrder[columnName];
        }

        // Handle dynamic columns (chronological order)
        if (columnName.StartsWith("FY", StringComparison.OrdinalIgnoreCase))
        {
            // Extract the integer part after "FY"
            if (int.TryParse(columnName.Substring(2, 4), out int year))
            {
                // Return a value based on the year
                // For example, FY2024 returns 10, FY2025 returns 11, etc.
                return year - 2014; // Adjust the offset as needed
            }
            else
            {
                // Handle the case where the column name doesn't contain a valid year
                return int.MaxValue; // Place invalid FY columns at the end
            }
        }
        // Parse month-year columns (e.g., SEP2024, OCT2024, etc.)
        if (columnName.Length >= 3)
        {
            var monthPart = columnName.Substring(0, 3);
            var yearPart = columnName.Length > 3 ? columnName.Substring(3, 4) : "";

            int previouscolumns = 13;
            var monthOrder = monthPart.ToUpper() switch
            {
	            "SEP" => previouscolumns + 12,
	            "OCT" => previouscolumns + 11,
	            "NOV" => previouscolumns + 10,
	            "DEC" => previouscolumns + 9,
	            "JAN" => previouscolumns + 8,
	            "FEB" => previouscolumns + 7,
	            "MAR" => previouscolumns + 6,
	            "APR" => previouscolumns + 5,
	            "MAY" => previouscolumns + 4,
	            "JUN" => previouscolumns + 3,
	            "JUL" => previouscolumns + 2,
	            "AUG" => previouscolumns + 1,

                _ => -1 // Unknown month
            };

            if (monthOrder != -1)
            {
                return monthOrder;
            }
        }

        // Default for unmatched columns
        return int.MaxValue; // Place unmatched columns at the end
    }

    private int GetColumnOrderX(string columnName)
    {
        // Implement logic to order columns chronologically

        return columnName switch
        {
            "Customer" => 0,
            "CustomerName" => 1,
            "ShipToNum" => 2,
            "Slsman" => 3,
            "Name" => 4,
            "BillToState" => 5,
            "Uf_SalesRegion" => 6,
            "RegionName" => 7,
            "Item" => 8,
            "ItemDescription" => 9,
            _ when columnName.StartsWith("FY") => 10,
            _ when columnName.StartsWith("SEP", StringComparison.OrdinalIgnoreCase) => 11,
            _ when columnName.StartsWith("OCT", StringComparison.OrdinalIgnoreCase) => 12,
            _ when columnName.StartsWith("NOV", StringComparison.OrdinalIgnoreCase) => 13,
            _ when columnName.StartsWith("DEC", StringComparison.OrdinalIgnoreCase) => 14,
            _ when columnName.StartsWith("JAN", StringComparison.OrdinalIgnoreCase) => 15,
            _ when columnName.StartsWith("FEB", StringComparison.OrdinalIgnoreCase) => 16,
            _ when columnName.StartsWith("MAR", StringComparison.OrdinalIgnoreCase) => 17,
            _ when columnName.StartsWith("APR", StringComparison.OrdinalIgnoreCase) => 18,
            _ when columnName.StartsWith("MAY", StringComparison.OrdinalIgnoreCase) => 19,
            _ when columnName.StartsWith("JUN", StringComparison.OrdinalIgnoreCase) => 20,
            _ when columnName.StartsWith("JUL", StringComparison.OrdinalIgnoreCase) => 21,
            _ when columnName.StartsWith("AUG", StringComparison.OrdinalIgnoreCase) => 22,
            _ => -1 // or some default value if none of the above match
        };

    }

    private void ConvertToExpandoObjects(List<SalesRecord> records)
    {
        foreach (var record in records)
        {
            dynamic expando = new ExpandoObject();
            var dict = expando as IDictionary<string, object>;

            foreach (var kvp in record)
            {
                dict[kvp.Key] = kvp.Value;
            }

            SalesData.Add(expando);
        }
    }

    // This property provides the filtered dynamic columns based on the user's toggle selection.
    public List<string> DynamicColumnsToShowOLD =>
        DynamicColumns.Where(col => showRevenue ? col.EndsWith("_Rev") : col.EndsWith("_Qty")).OrderBy(GetColumnOrder).ToList();



    // Toggles the selection between Revenue and Quantity columns.
    void ToggleDataTypeOLD()
    {



        showRevenue = !showRevenue;
        Grid.RefreshColumnsAsync();
        Console.WriteLine("Dynamic Columns after toggle: " + string.Join(", ", DynamicColumns));
        Console.WriteLine("Dynamic Columns to show after toggle: " + string.Join(", ", DynamicColumnsToShow));
    }

    // Toggles the selection and updates the list of columns to display
    void ToggleDataType()
    {
	
	    showRevenue = !showRevenue;
	    UpdateDynamicColumnsToShow(); // <--- Use the helper
	    StateHasChanged();

    }

    private void UpdateDynamicColumnsToShow()
    {
	    // Use the master list (ensure it's populated)
        DynamicColumnsToShow = KeysToAggregate
		    .Where(col => showRevenue ? col.EndsWith("_Rev", StringComparison.OrdinalIgnoreCase) : col.EndsWith("_Qty", StringComparison.OrdinalIgnoreCase))
		    .OrderBy(GetColumnOrder) // Keep your original ordering logic
		    .ToList();

	    Console.WriteLine($"Updated DynamicColumnsToShow (Show Revenue: {showRevenue}): {string.Join(", ", DynamicColumnsToShow)}");
    }

    private void ProcessDynamicColumnsAndPopulateKeysToAggregate(List<Dictionary<string, object>> records)
    {
	    if (records == null || !records.Any())
	    {
		    KeysToAggregate = new List<string>();
		    return;
	    }
	    // Discover all non-fixed keys from the data
	    KeysToAggregate = records
		    .SelectMany(r => r.Keys)
		    .Where(k => !IsFixedColumn(k)) // Your existing IsFixedColumn check
		    .Distinct()
		    // .OrderBy(GetColumnOrder) // Order here IF needed for KeysToAggregate itself, otherwise ordering is done in UpdateDynamicColumnsToShow
		    .ToList();

	    Console.WriteLine("Populated KeysToAggregate: " + string.Join(", ", KeysToAggregate));
    }

}